"""
Bzlmod module extension for mabel Maven dependency management.

This extension reads a lockfile (generated by running mabel_rule) and creates
repository rules for all Maven artifacts without needing to re-resolve dependencies.
"""

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_file")
load("@mabel//rules/jvm_import:jvm_import.bzl", "jvm_import")

def _jvm_import_repo_impl(rctx):
    """Creates a repository with a single jvm_import target."""
    # Create a BUILD file with the jvm_import target
    rctx.file("BUILD.bazel", """
load("@mabel//rules/jvm_import:jvm_import.bzl", "jvm_import")

jvm_import(
    name = "jar",
    jars = ["@{jar_repo}//file"],
    visibility = ["//visibility:public"],
    {deps}
    {exports}
    {runtime_deps}
)
""".format(
        jar_repo = rctx.attr.jar_repo,
        deps = "deps = {},".format(rctx.attr.deps) if rctx.attr.deps else "",
        exports = "exports = {},".format(rctx.attr.exports) if rctx.attr.exports else "",
        runtime_deps = "runtime_deps = {},".format(rctx.attr.runtime_deps) if rctx.attr.runtime_deps else "",
    ))

_jvm_import_repo = repository_rule(
    implementation = _jvm_import_repo_impl,
    attrs = {
        "jar_repo": attr.string(mandatory = True),
        "deps": attr.string_list(default = []),
        "exports": attr.string_list(default = []),
        "runtime_deps": attr.string_list(default = []),
    },
)

def _normalize(name):
    """Normalize Maven name by replacing special characters with underscores."""
    return name.replace("+", "_").replace(".", "_").replace("-", "_")

def _get_file_path_from_maven_name(group_id, artifact_id):
    """Convert Maven groupId:artifactId to a file path.

    Example: com.google.guava:guava -> com/google/guava/guava
    """
    return group_id.replace(".", "/") + "/" + artifact_id

def _parse_maven_coordinate(coordinate):
    """Parse a Maven coordinate string into (groupId, artifactId, version)."""
    parts = coordinate.split(":")
    if len(parts) < 3:
        fail("Invalid Maven coordinate: {}".format(coordinate))
    return parts[0], parts[1], parts[2]

def _maven_alias_repo_impl(rctx):
    """Creates a repository with alias targets pointing to versioned repos.

    This repository contains a directory structure based on Maven groupId and artifactId,
    with alias targets pointing to the actual versioned repositories.

    For example, for com.google.guava:guava:20.0, creates:
      @maven//com/google/guava/guava:guava -> @com_google_guava__guava__20_0//:jar
    """

    # Parse the artifacts list - format is ["coordinate|repo_name|target_type", ...]
    for artifact_info in rctx.attr.artifacts:
        parts = artifact_info.split("|")
        if len(parts) != 3:
            fail("Invalid artifact info format: {}".format(artifact_info))

        maven_coordinate = parts[0]
        repo_name = parts[1]
        target_type = parts[2]

        group_id, artifact_id, version = _parse_maven_coordinate(maven_coordinate)

        # Create the directory path: com/google/guava/guava
        file_path = _get_file_path_from_maven_name(group_id, artifact_id)

        # Create BUILD file with alias
        build_content = """# Alias for {coordinate}
alias(
    name = "{artifact_id}",
    actual = "@{repo_name}//:{target_type}",
    visibility = ["//visibility:public"],
)
""".format(
            coordinate = maven_coordinate,
            artifact_id = artifact_id,
            repo_name = repo_name,
            target_type = target_type,
        )

        rctx.file(file_path + "/BUILD.bazel", build_content)

    # Create root BUILD file
    rctx.file("BUILD.bazel", """# Mabel Maven alias repository
# This repository contains alias targets for Maven artifacts.
# Use @{name}//group/id/artifact:artifact instead of @group_id__artifact_id__version//:jar
# Import this repository via use_repo() with your preferred name.
""".format(name = rctx.name))

_maven_alias_repo = repository_rule(
    implementation = _maven_alias_repo_impl,
    attrs = {
        "artifacts": attr.string_list(
            doc = "List of artifact info strings in format 'coordinate|repo_name|target_type'",
            mandatory = True,
        ),
    },
)

def _maven_install_impl(module_ctx):
    """
    Module extension implementation that reads the lockfile and creates repos.

    This function:
    1. Reads the JSON lockfile specified by the user
    2. Parses the artifact metadata
    3. Creates http_file repository rules for each Maven artifact
    4. Creates an alias repository for convenient access to artifacts
    """

    # Track created repositories to avoid duplicates across lockfiles
    created_repos = {}

    # Collect all artifacts for the alias repository
    # Format: "coordinate|repo_name|target_type"
    all_artifacts = []

    # Collect all install tags from modules that use this extension
    for mod in module_ctx.modules:
        for install in mod.tags.install:
            lockfile_path = install.lockfile

            # Read the lockfile
            lockfile_content = module_ctx.read(lockfile_path)
            lockfile = json.decode(lockfile_content)

            # Validate lockfile version
            if lockfile.get("version") != "1.0":
                fail("Unsupported lockfile version: {}".format(lockfile.get("version")))

            # Create repository rules for each artifact
            artifacts = lockfile.get("artifacts", {})
            for maven_coordinate, artifact_info in artifacts.items():
                repo_name = artifact_info.get("repo_name")
                url = artifact_info.get("url")
                sha256 = artifact_info.get("sha256")
                target_type = artifact_info.get("target_type", "jar")

                if not repo_name or not url:
                    fail("Invalid artifact entry for {}: missing repo_name or url".format(maven_coordinate))

                # Skip if this repo was already created from another lockfile
                if repo_name in created_repos:
                    # Verify that the URL and sha256 match (same version)
                    existing = created_repos[repo_name]
                    if existing["url"] != url:
                        fail("Repository {} defined multiple times with different URLs: {} vs {}".format(
                            repo_name, existing["url"], url))
                    if existing.get("sha256") != sha256:
                        fail("Repository {} defined multiple times with different sha256: {} vs {}".format(
                            repo_name, existing.get("sha256"), sha256))
                    continue

                # Track this repo
                created_repos[repo_name] = {"url": url, "sha256": sha256}

                # Add to artifacts list for alias repo
                all_artifacts.append("{}|{}|{}".format(maven_coordinate, repo_name, target_type))

                # Create http_file repository rule for downloading the JAR
                jar_repo_name = repo_name + "__jar"
                http_file_attrs = {
                    "urls": [url],
                    "downloaded_file_path": url.split("/")[-1],  # Extract filename from URL
                }

                # Add sha256 if available (not present for SNAPSHOTs)
                if sha256:
                    http_file_attrs["sha256"] = sha256

                http_file(
                    name = jar_repo_name,
                    **http_file_attrs
                )

                # Create jvm_import wrapper repository
                deps = artifact_info.get("dependencies", [])
                exports = artifact_info.get("exports", [])
                runtime_deps = artifact_info.get("runtime_deps", [])

                _jvm_import_repo(
                    name = repo_name,
                    jar_repo = jar_repo_name,
                    deps = ["@" + d for d in deps],
                    exports = ["@" + e for e in exports],
                    runtime_deps = ["@" + r for r in runtime_deps],
                )

                # Create http_file for sources if available
                sources = artifact_info.get("sources")
                if sources and sources.get("url"):
                    sources_repo_name = repo_name + "__sources"

                    # Skip if sources repo already created
                    if sources_repo_name not in created_repos:
                        sources_attrs = {
                            "urls": [sources["url"]],
                            "downloaded_file_path": sources["url"].split("/")[-1],
                        }
                        if sources.get("sha256"):
                            sources_attrs["sha256"] = sources["sha256"]

                        http_file(
                            name = sources_repo_name,
                            **sources_attrs
                        )
                        created_repos[sources_repo_name] = {"url": sources["url"], "sha256": sources.get("sha256")}

    # Create the alias repository
    # This allows users to reference artifacts as @maven//group/id/artifact:artifact
    # Users import this via use_repo() with whatever name they prefer
    if all_artifacts:
        _maven_alias_repo(
            name = "maven",
            artifacts = all_artifacts,
        )

# Define the tag class for the install operation
_install_tag = tag_class(
    attrs = {
        "lockfile": attr.label(
            doc = "Label pointing to the Maven lockfile (e.g., '//resolver:maven_install.json')",
            mandatory = True,
        ),
    },
)

# Define the module extension
maven = module_extension(
    implementation = _maven_install_impl,
    tag_classes = {
        "install": _install_tag,
    },
)
