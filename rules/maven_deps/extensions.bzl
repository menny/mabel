"""
Bzlmod module extension for mabel Maven dependency management.

This extension reads a lockfile (generated by running mabel_rule) and creates
repository rules for all Maven artifacts without needing to re-resolve dependencies.
"""

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_file")

def _jvm_import_repo_impl(rctx):
    """Creates a repository with jvm_import and optionally java_plugin targets for processors."""
    processor_classes = rctx.attr.processor_classes

    # Build the jvm_import target
    build_content = """
load("@mabel//rules/jvm_import:jvm_import.bzl", "jvm_import")

jvm_import(
    name = "jar",
    jars = ["@{jar_repo}//file"],
    visibility = ["//visibility:public"],
    {deps}
    {exports}
    {runtime_deps}
)
""".format(
        jar_repo = rctx.attr.jar_repo,
        deps = "deps = {},".format(rctx.attr.deps) if rctx.attr.deps else "",
        exports = "exports = {},".format(rctx.attr.exports) if rctx.attr.exports else "",
        runtime_deps = "runtime_deps = {},".format(rctx.attr.runtime_deps) if rctx.attr.runtime_deps else "",
    )

    # If this is a processor, add java_plugin targets
    if processor_classes:
        # Deps for java_plugin include the jar itself plus runtime deps
        plugin_deps = [":jar"] + rctx.attr.runtime_deps + rctx.attr.deps
        plugin_deps_str = str(plugin_deps)

        no_api_plugins = []
        with_api_plugins = []

        for i, processor_class in enumerate(processor_classes):
            no_api_name = "___processor_class_{}".format(i)
            with_api_name = "___generates_api___processor_class_{}".format(i)
            no_api_plugins.append(":{}".format(no_api_name))
            with_api_plugins.append(":{}".format(with_api_name))

            # java_plugin without generates_api
            build_content += """
java_plugin(
    name = "{name}",
    processor_class = "{processor_class}",
    generates_api = False,
    deps = {deps},
    visibility = ["//visibility:public"],
)
""".format(name = no_api_name, processor_class = processor_class, deps = plugin_deps_str)

            # java_plugin with generates_api
            build_content += """
java_plugin(
    name = "{name}",
    processor_class = "{processor_class}",
    generates_api = True,
    deps = {deps},
    visibility = ["//visibility:public"],
)
""".format(name = with_api_name, processor_class = processor_class, deps = plugin_deps_str)

        # java_library that exports all non-API plugins
        build_content += """
java_library(
    name = "___processor_class_all",
    exported_plugins = {plugins},
    visibility = ["//visibility:public"],
)
""".format(plugins = str(no_api_plugins))

        # java_library that exports all API-generating plugins
        build_content += """
java_library(
    name = "___generates_api___processor_class_all",
    exported_plugins = {plugins},
    visibility = ["//visibility:public"],
)
""".format(plugins = str(with_api_plugins))

    rctx.file("BUILD.bazel", build_content)

_jvm_import_repo = repository_rule(
    implementation = _jvm_import_repo_impl,
    attrs = {
        "jar_repo": attr.string(mandatory = True),
        "deps": attr.string_list(default = []),
        "exports": attr.string_list(default = []),
        "runtime_deps": attr.string_list(default = []),
        "processor_classes": attr.string_list(default = []),
    },
)

def _get_file_path_from_maven_name(group_id, artifact_id):
    """Convert Maven groupId:artifactId to a file path.

    Example: com.google.guava:guava -> com/google/guava/guava
    """
    return group_id.replace(".", "/") + "/" + artifact_id

def _parse_maven_coordinate(coordinate):
    """Parse a Maven coordinate string into (groupId, artifactId, version)."""
    parts = coordinate.split(":")
    if len(parts) < 3:
        fail("Invalid Maven coordinate: {}".format(coordinate))
    return parts[0], parts[1], parts[2]

def _maven_alias_repo_impl(rctx):
    """Creates a repository with alias targets pointing to versioned repos.

    This repository contains a directory structure based on Maven groupId and artifactId,
    with alias targets pointing to the actual versioned repositories.

    For example, for com.google.guava:guava:20.0, creates:
      @maven//com/google/guava/guava:guava -> @com_google_guava__guava__20_0//:jar
    """

    # Parse the artifacts list - format is ["coordinate|repo_name|target_type|processor_classes_count", ...]
    for artifact_info in rctx.attr.artifacts:
        parts = artifact_info.split("|")
        if len(parts) < 3:
            fail("Invalid artifact info format: {}".format(artifact_info))

        maven_coordinate = parts[0]
        repo_name = parts[1]
        target_type = parts[2]
        processor_classes_count = int(parts[3]) if len(parts) > 3 else 0

        group_id, artifact_id, version = _parse_maven_coordinate(maven_coordinate)

        # Create the directory path: com/google/guava/guava
        file_path = _get_file_path_from_maven_name(group_id, artifact_id)

        # Create BUILD file with alias for the main jar
        build_content = """# Alias for {coordinate}
alias(
    name = "{artifact_id}",
    actual = "@{repo_name}//:jar",
    visibility = ["//visibility:public"],
)
""".format(
            coordinate = maven_coordinate,
            artifact_id = artifact_id,
            repo_name = repo_name,
        )

        # If this is a processor, add aliases for processor targets
        if processor_classes_count > 0:
            for i in range(processor_classes_count):
                # Alias for individual processor without API
                build_content += """
alias(
    name = "{artifact_id}___processor_class_{i}",
    actual = "@{repo_name}//:___processor_class_{i}",
    visibility = ["//visibility:public"],
)
""".format(artifact_id = artifact_id, repo_name = repo_name, i = i)

                # Alias for individual processor with API
                build_content += """
alias(
    name = "{artifact_id}___generates_api___processor_class_{i}",
    actual = "@{repo_name}//:___generates_api___processor_class_{i}",
    visibility = ["//visibility:public"],
)
""".format(artifact_id = artifact_id, repo_name = repo_name, i = i)

            # Alias for all processors without API
            build_content += """
alias(
    name = "{artifact_id}___processors",
    actual = "@{repo_name}//:___processor_class_all",
    visibility = ["//visibility:public"],
)
""".format(artifact_id = artifact_id, repo_name = repo_name)

            # Alias for all processors with API
            build_content += """
alias(
    name = "{artifact_id}___processors_with_api",
    actual = "@{repo_name}//:___generates_api___processor_class_all",
    visibility = ["//visibility:public"],
)
""".format(artifact_id = artifact_id, repo_name = repo_name)

        rctx.file(file_path + "/BUILD.bazel", build_content)

    # Create root BUILD file
    rctx.file("BUILD.bazel", """# Mabel Maven alias repository
# This repository contains alias targets for Maven artifacts.
# Use @{name}//group/id/artifact:artifact instead of @group_id__artifact_id__version//:jar
# Import this repository via use_repo() with your preferred name.
""".format(name = rctx.name))

_maven_alias_repo = repository_rule(
    implementation = _maven_alias_repo_impl,
    attrs = {
        "artifacts": attr.string_list(
            doc = "List of artifact info strings in format 'coordinate|repo_name|target_type'",
            mandatory = True,
        ),
    },
)

def _mabel_install_impl(module_ctx):
    """
    Module extension implementation that reads the lockfile and creates repos.

    This function:
    1. Reads the JSON lockfile specified by the user
    2. Parses the artifact metadata
    3. Creates http_file repository rules for each Maven artifact
    4. Creates an alias repository for convenient access to artifacts
    """

    # Track created repositories to avoid duplicates across lockfiles
    created_repos = {}

    for mod in module_ctx.modules:
        for install in mod.tags.install:
            lockfile_path = install.lockfile
            all_artifacts = []

            # Read the lockfile
            lockfile_content = module_ctx.read(lockfile_path)
            lockfile = json.decode(lockfile_content)

            # Validate lockfile version
            if lockfile.get("version") != "1.0":
                fail("Unsupported lockfile version: {}".format(lockfile.get("version")))

            # Create repository rules for each artifact
            artifacts = lockfile.get("artifacts", {})

            # First pass: build a mapping from target_name (groupId__artifactId) to repo_name (groupId__artifactId__version)
            # This is needed because deps in the lockfile use target_name format
            target_name_to_repo_name = {}
            for maven_coordinate, artifact_info in artifacts.items():
                repo_name = artifact_info.get("repo_name")
                # Target name is groupId__artifactId (without version)
                # Repo name is groupId__artifactId__version
                # Extract target name by removing the version suffix
                parts = repo_name.rsplit("__", 1)
                if len(parts) == 2:
                    target_name = parts[0]
                    target_name_to_repo_name[target_name] = repo_name

            for maven_coordinate, artifact_info in artifacts.items():
                repo_name = artifact_info.get("repo_name")
                url = artifact_info.get("url")
                sha256 = artifact_info.get("sha256")
                target_type = artifact_info.get("target_type", "jar")
                processor_classes = artifact_info.get("processor_classes", [])

                if not repo_name or not url:
                    fail("Invalid artifact entry for {}: missing repo_name or url".format(maven_coordinate))

                # Add to artifacts list for alias repo (always, even if repo already exists)
                # Format: coordinate|repo_name|target_type|processor_classes_count
                all_artifacts.append("{}|{}|{}|{}".format(
                    maven_coordinate,
                    repo_name,
                    target_type,
                    len(processor_classes),
                ))

                # Skip creating repos if this repo was already created from another lockfile
                if repo_name in created_repos:
                    # Verify that the URL and sha256 match (same version)
                    existing = created_repos[repo_name]
                    if existing["url"] != url:
                        fail("Repository {} defined multiple times with different URLs: {} vs {}".format(
                            repo_name,
                            existing["url"],
                            url,
                        ))
                    if existing.get("sha256") != sha256:
                        fail("Repository {} defined multiple times with different sha256: {} vs {}".format(
                            repo_name,
                            existing.get("sha256"),
                            sha256,
                        ))
                    continue

                # Track this repo
                created_repos[repo_name] = {"url": url, "sha256": sha256}

                # Create http_file repository rule for downloading the JAR
                jar_repo_name = repo_name + "__jar"
                http_file_attrs = {
                    "urls": [url],
                    "downloaded_file_path": url.split("/")[-1],  # Extract filename from URL
                }

                # Add sha256 if available (not present for SNAPSHOTs)
                if sha256:
                    http_file_attrs["sha256"] = sha256

                http_file(
                    name = jar_repo_name,
                    **http_file_attrs
                )

                # Create jvm_import wrapper repository
                deps = artifact_info.get("dependencies", [])
                exports = artifact_info.get("exports", [])
                runtime_deps = artifact_info.get("runtime_deps", [])

                # Convert dependency references to proper repo labels
                # Dependencies come as ":target_name" format (without version) from the lockfile
                # We need to map them to full repo names (with version)
                def _to_repo_label(dep):
                    # Remove leading colon if present
                    target_name = dep[1:] if dep.startswith(":") else dep
                    # Look up the full repo name from our mapping
                    full_repo_name = target_name_to_repo_name.get(target_name, target_name)
                    return "@" + full_repo_name + "//:jar"

                _jvm_import_repo(
                    name = repo_name,
                    jar_repo = jar_repo_name,
                    deps = [_to_repo_label(d) for d in deps],
                    exports = [_to_repo_label(e) for e in exports],
                    runtime_deps = [_to_repo_label(r) for r in runtime_deps],
                    processor_classes = processor_classes,
                )

                # Create http_file for sources if available
                sources = artifact_info.get("sources")
                if sources and sources.get("url"):
                    sources_repo_name = repo_name + "__sources"

                    # Skip if sources repo already created
                    if sources_repo_name not in created_repos:
                        sources_attrs = {
                            "urls": [sources["url"]],
                            "downloaded_file_path": sources["url"].split("/")[-1],
                        }
                        if sources.get("sha256"):
                            sources_attrs["sha256"] = sources["sha256"]

                        http_file(
                            name = sources_repo_name,
                            **sources_attrs
                        )
                        created_repos[sources_repo_name] = {"url": sources["url"], "sha256": sources.get("sha256")}

            # Creating the aliases repo
            _maven_alias_repo(
                name = install.aliases_repo,
                artifacts = all_artifacts,
            )

# Define the tag class for the install operation
_install_tag = tag_class(
    attrs = {
        "lockfile": attr.label(
            doc = "Label pointing to the Maven lockfile (e.g., '//resolver:maven_install.json')",
            mandatory = True,
        ),
        "aliases_repo": attr.string(
            doc = "The name of the repo to use for aliases.",
            mandatory = True,
        ),
    },
)

# Define the module extension
mabel = module_extension(
    implementation = _mabel_install_impl,
    tag_classes = {
        "install": _install_tag,
    },
)
